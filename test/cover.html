
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>postman: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sharkattack51/postman/cmd/postman/auth.go (0.0%)</option>
				
				<option value="file1">github.com/sharkattack51/postman/cmd/postman/http_handlers.go (11.2%)</option>
				
				<option value="file2">github.com/sharkattack51/postman/cmd/postman/logger.go (0.0%)</option>
				
				<option value="file3">github.com/sharkattack51/postman/cmd/postman/main.go (16.8%)</option>
				
				<option value="file4">github.com/sharkattack51/postman/cmd/postman/message.go (55.9%)</option>
				
				<option value="file5">github.com/sharkattack51/postman/cmd/postman/os_handler.go (0.0%)</option>
				
				<option value="file6">github.com/sharkattack51/postman/cmd/postman/plugin.go (0.0%)</option>
				
				<option value="file7">github.com/sharkattack51/postman/cmd/postman/store.go (0.0%)</option>
				
				<option value="file8">github.com/sharkattack51/postman/cmd/postman/util.go (33.3%)</option>
				
				<option value="file9">github.com/sharkattack51/postman/cmd/postman/websocket_handlers.go (33.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        jwt "github.com/golang-jwt/jwt/v5"
)

func GenerateToken(scrt string, key string) (string, error) <span class="cov0" title="0">{
        tkn := jwt.NewWithClaims(jwt.SigningMethodHS256, &amp;jwt.MapClaims{
                "key": key,
        })
        tknStr, err := tkn.SignedString([]byte(scrt))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tknStr, nil</span>
}

func Authenticate(scrt string, tknStr string, key string) (bool, error) <span class="cov0" title="0">{
        tkn, err := jwt.Parse(tknStr, func(tkn *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(scrt), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">claims := tkn.Claims.(jwt.MapClaims)
        return claims["key"].(string) == key, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "html"
        "log"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/sirupsen/logrus"
)

//
// Http Handlers
//

func PublishHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov8" title="1">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "publish", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov8" title="1">params := make(map[string]string)
        query := r.URL.Query()
        for _, s := range []string{"channel", "ch", "message", "msg", "tag", "extention", "ext", "client_info", "ci"} </span><span class="cov8" title="1">{
                param := query[s]
                if len(param) &gt; 0 </span><span class="cov8" title="1">{
                        params[s] = param[0]
                }</span> else<span class="cov8" title="1"> {
                        params[s] = ""
                }</span>
        }

        <span class="cov8" title="1">hasQuery := false
        if params["channel"] != "" || params["ch"] != "" </span><span class="cov8" title="1">{
                hasQuery = true
        }</span>

        // for GET url-param
        <span class="cov8" title="1">msg := NewPublishMessage(params["channel"], params["ch"], params["message"], params["msg"], params["tag"], params["extention"], params["ext"], params["client_info"], params["ci"])

        // for POST form-data
        if !hasQuery </span><span class="cov0" title="0">{
                r.ParseForm()
                if len(r.Form) &gt; 0 </span><span class="cov0" title="0">{
                        if data, ok := r.Form["json"]; ok </span><span class="cov0" title="0">{
                                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                        json.Unmarshal([]byte(data[0]), msg)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">remote := r.RemoteAddr
        infoAtRemote := remote
        if msg.Info() != "" </span><span class="cov0" title="0">{
                infoAtRemote = msg.Info() + "@" + remote
        }</span>

        <span class="cov8" title="1">if msg.Channel() == "" </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] publish channel is empty from %s\n", infoAtRemote)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "publish channel is empty", logrus.Fields{"method": "publish", "channel": msg.Channel(), "message": msg.Message(), "tag": msg.Tag(), "extention": msg.Extention(), "from": infoAtRemote})
                }</span>

                <span class="cov0" title="0">res := NewResultMessage("fail", "publish channel is empty")
                j, _ := json.Marshal(res)
                fmt.Fprint(w, string(j))</span>
        } else<span class="cov8" title="1"> {
                log.Printf("&gt; [Publish] ch:%s msg:%s from %s\n", msg.Channel(), msg.BuildLogString(), infoAtRemote)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(INFO, "new publish", logrus.Fields{"method": "publish", "channel": msg.Channel(), "message": msg.Message(), "tag": msg.Tag(), "extention": msg.Extention(), "from": infoAtRemote})
                }</span>

                <span class="cov8" title="1">pmsg := NewPublishSendMessage(msg.Channel(), msg.Message(), msg.Tag(), msg.Extention())
                if roomMg != nil </span><span class="cov8" title="1">{
                        if strings.HasSuffix(msg.Channel(), "/*") </span><span class="cov0" title="0">{
                                groupCh := strings.TrimSuffix(msg.Channel(), "/*")
                                for _, ri := range roomMg.GetRoomInfos() </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(ri.Topic, groupCh) </span><span class="cov0" title="0">{
                                                ck := strings.TrimPrefix(ri.Topic, groupCh)
                                                if len(ck) &gt; 0 &amp;&amp; strings.HasPrefix(ck, "/") </span><span class="cov0" title="0">{
                                                        roomMg.Emit(ri.Topic, "message", &amp;pmsg)
                                                }</span>
                                        }
                                }
                        } else<span class="cov8" title="1"> {
                                roomMg.Emit(msg.Channel(), "message", &amp;pmsg)
                        }</span>
                }

                <span class="cov8" title="1">res := NewResultMessage("success", "")
                j, _ := json.Marshal(res)
                fmt.Fprint(w, string(j))</span>
        }
}

func StatusHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov8" title="1">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "status", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov8" title="1">log.Printf("&gt; [Status] get status from %s\n", r.RemoteAddr)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "get status", logrus.Fields{"method": "status", "from": r.RemoteAddr})
        }</span>

        <span class="cov8" title="1">msg := NewStatusMessage(roomMg)
        j, _ := json.Marshal(msg)
        fmt.Fprint(w, string(j))</span>
}

func StatusPpHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov8" title="1">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "status_pp", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov8" title="1">log.Printf("&gt; [Status] get status pp from %s\n", r.RemoteAddr)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "get status pp", logrus.Fields{"method": "status_pp", "from": r.RemoteAddr})
        }</span>

        <span class="cov8" title="1">msg := NewStatusMessage(roomMg)
        j, _ := json.MarshalIndent(msg, "", "    ")
        fmt.Fprint(w, string(j))</span>
}

func StoreHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "store", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov0" title="0">if !opts.UseStoreApi || kvsDB == nil </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] key-value store api is disable from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "key-value store api is disable", logrus.Fields{"method": "file", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "key-value store api is disable")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">params := make(map[string]string)
        query := r.URL.Query()
        for _, s := range []string{"command", "cmd", "key", "value", "val"} </span><span class="cov0" title="0">{
                param := query[s]
                if len(param) &gt; 0 </span><span class="cov0" title="0">{
                        params[s] = param[0]
                }</span> else<span class="cov0" title="0"> {
                        params[s] = ""
                }</span>
        }

        <span class="cov0" title="0">hasQuery := false
        if (params["command"] != "" || params["cmd"] != "") &amp;&amp; params["key"] != "" </span><span class="cov0" title="0">{
                hasQuery = true
        }</span>

        // for GET url-param
        <span class="cov0" title="0">msg := NewStoreMessage(params["command"], params["cmd"], params["key"], params["value"], params["val"])

        // for POST form-data
        if !hasQuery </span><span class="cov0" title="0">{
                r.ParseForm()
                if len(r.Form) &gt; 0 </span><span class="cov0" title="0">{
                        if data, ok := r.Form["json"]; ok </span><span class="cov0" title="0">{
                                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                        json.Unmarshal([]byte(data[0]), msg)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if msg.Command() != "" </span><span class="cov0" title="0">{
                if msg.Key() != "" </span><span class="cov0" title="0">{
                        switch strings.ToLower(msg.Command()) </span>{
                        case "get":<span class="cov0" title="0">
                                log.Printf("&gt; [Store] cmd:%s key:%s from %s\n", msg.Command(), msg.Key(), r.RemoteAddr)
                                if logger != nil </span><span class="cov0" title="0">{
                                        logger.Log(INFO, "request store get", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "from": r.RemoteAddr})
                                }</span>

                                <span class="cov0" title="0">v, err := StoreGet(kvsDB, msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        res := NewResultMessage("", "") // Key無しの場合
                                        j, _ := json.Marshal(res)
                                        fmt.Fprint(w, string(j))
                                        return
                                }</span>

                                <span class="cov0" title="0">res := NewResultMessage(v, "")
                                j, _ := json.Marshal(res)
                                fmt.Fprint(w, string(j))</span>

                        case "set":<span class="cov0" title="0">
                                log.Printf("&gt; [Store] cmd:%s key:%s val:%s from %s\n", msg.Command(), msg.Key(), msg.Value(), r.RemoteAddr)
                                if logger != nil </span><span class="cov0" title="0">{
                                        logger.Log(INFO, "request store set", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "val": msg.Value(), "from": r.RemoteAddr})
                                }</span>

                                <span class="cov0" title="0">err := StoreSet(kvsDB, msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        res := NewResultMessage("fail", err.Error())
                                        j, _ := json.Marshal(res)
                                        fmt.Fprint(w, string(j))
                                        return
                                }</span>

                                <span class="cov0" title="0">res := NewResultMessage("success", "")
                                j, _ := json.Marshal(res)
                                fmt.Fprint(w, string(j))</span>

                        case "has":<span class="cov0" title="0">
                                log.Printf("&gt; [Store] cmd:%s key:%s from %s\n", msg.Command(), msg.Key(), r.RemoteAddr)
                                if logger != nil </span><span class="cov0" title="0">{
                                        logger.Log(INFO, "request store haskey", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "from": r.RemoteAddr})
                                }</span>

                                <span class="cov0" title="0">b, err := StoreHas(kvsDB, msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        res := NewResultMessage("fail", err.Error())
                                        j, _ := json.Marshal(res)
                                        fmt.Fprint(w, string(j))
                                        return
                                }</span>

                                <span class="cov0" title="0">res := NewResultMessage(strconv.FormatBool(b), "")
                                j, _ := json.Marshal(res)
                                fmt.Fprint(w, string(j))</span>

                        case "del":<span class="cov0" title="0">
                                log.Printf("&gt; [Store] cmd:%s key:%s from %s\n", msg.Command(), msg.Key(), r.RemoteAddr)
                                if logger != nil </span><span class="cov0" title="0">{
                                        logger.Log(INFO, "request store delete", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "from": r.RemoteAddr})
                                }</span>

                                <span class="cov0" title="0">err := StoreDelete(kvsDB, msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        res := NewResultMessage("fail", err.Error())
                                        j, _ := json.Marshal(res)
                                        fmt.Fprint(w, string(j))
                                        return
                                }</span>

                                <span class="cov0" title="0">res := NewResultMessage("success", "")
                                j, _ := json.Marshal(res)
                                fmt.Fprint(w, string(j))</span>

                        default:<span class="cov0" title="0">
                                log.Printf("&gt; [Warning] store command nou found from %s\n", r.RemoteAddr)
                                if logger != nil </span><span class="cov0" title="0">{
                                        logger.Log(WARN, "command not found", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "value": msg.Value(), "from": r.RemoteAddr})
                                }</span>

                                <span class="cov0" title="0">res := NewResultMessage("fail", "store command not found")
                                j, _ := json.Marshal(res)
                                fmt.Fprint(w, string(j))</span>
                        }
                } else<span class="cov0" title="0"> {
                        log.Printf("&gt; [Warning] store key is empty from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "store key is empty", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "value": msg.Value(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">res := NewResultMessage("fail", "store key is empty")
                        j, _ := json.Marshal(res)
                        fmt.Fprint(w, string(j))</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("&gt; [Warning] store command is empty from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "store command is empty", logrus.Fields{"method": "store", "command": msg.Command(), "key": msg.Key(), "value": msg.Value(), "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">res := NewResultMessage("fail", "store command is empty")
                j, _ := json.Marshal(res)
                fmt.Fprint(w, string(j))</span>
        }
}

func SecureHandler(r *http.Request) *SecureMessage <span class="cov0" title="0">{
        params := make(map[string]string)
        query := r.URL.Query()
        for _, s := range []string{"token", "tkn", "password", "pwd"} </span><span class="cov0" title="0">{
                param := query[s]
                if len(param) &gt; 0 </span><span class="cov0" title="0">{
                        params[s] = param[0]
                }</span> else<span class="cov0" title="0"> {
                        params[s] = ""
                }</span>
        }

        <span class="cov0" title="0">hasQuery := false
        if params["token"] != "" || params["tkn"] != "" </span><span class="cov0" title="0">{
                hasQuery = true
        }</span>

        // for GET url-param
        <span class="cov0" title="0">msg := NewSecureMessage(params["token"], params["tkn"])

        // for POST form-data
        if !hasQuery </span><span class="cov0" title="0">{
                r.ParseForm()
                if len(r.Form) &gt; 0 </span><span class="cov0" title="0">{
                        if data, ok := r.Form["json"]; ok </span><span class="cov0" title="0">{
                                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                        json.Unmarshal([]byte(data[0]), msg)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return msg</span>
}

func FileHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "store", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov0" title="0">if !opts.UseFileApi </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] file server api is disable from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "file server api is disable", logrus.Fields{"method": "file", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "file server api is disable")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">if !IsExist(SERVE_FILES_DIR) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] directory not found \"%s\" from %s\n", SERVE_FILES_DIR, r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, fmt.Sprintf("directory not found \"%s\"", SERVE_FILES_DIR), logrus.Fields{"method": "file post", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", fmt.Sprintf("directory not found \"%s\"", SERVE_FILES_DIR))
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">if r.Method == "POST" </span><span class="cov0" title="0">{
                formFile, header, err := r.FormFile("file")
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] no form file data from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "no form file data", logrus.Fields{"method": "file post", "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "no form file data")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
                <span class="cov0" title="0">defer formFile.Close()

                path := filepath.Join(SERVE_FILES_DIR, header.Filename)
                file, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] could not open file \"%s\" from %s\n", header.Filename, r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "could not open file", logrus.Fields{"method": "file post", "file": header.Filename, "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", fmt.Sprintf("could not open file \"%s\"", header.Filename))
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
                <span class="cov0" title="0">defer file.Close()

                data := make([]byte, 1024)
                offset := int64(0)
                for </span><span class="cov0" title="0">{
                        n, err := formFile.Read(data)
                        if n == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }

                        // write file
                        <span class="cov0" title="0">file.WriteAt(data, offset)
                        offset += int64(n)</span>
                }

                <span class="cov0" title="0">log.Printf("&gt; [File] new file posted \"%s\" from %s\n", header.Filename, r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(INFO, "new file posted", logrus.Fields{"method": "file post", "file": header.Filename, "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("success", "")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))</span>

        } else<span class="cov0" title="0"> if r.Method == "GET" </span><span class="cov0" title="0">{
                urls := strings.Split(r.URL.Path, "/postman/file/")
                pathToFile := ""
                if len(urls) &gt;= 2 </span><span class="cov0" title="0">{
                        pathToFile = urls[1]
                }</span>
                <span class="cov0" title="0">pathToFile = html.UnescapeString(pathToFile)
                if pathToFile == "" </span><span class="cov0" title="0">{
                        pathToFile = "index.html"
                }</span>

                <span class="cov0" title="0">path := filepath.Join(SERVE_FILES_DIR, pathToFile)

                if !IsExist(path) </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] file not found \"%s\" from %s\n", pathToFile, r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "file not found", logrus.Fields{"method": "file get", "name": pathToFile, "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", fmt.Sprintf("file not found \"%s\"", pathToFile))
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }

                <span class="cov0" title="0">log.Printf("&gt; [File] serve access \"%s\" from %s\n", pathToFile, r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(INFO, "file served", logrus.Fields{"method": "file get", "file": pathToFile, "from": r.RemoteAddr})
                }</span>

                // return file
                <span class="cov0" title="0">http.ServeFile(w, r, path)</span>
        }
}

func PluginHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        AllowCORS(w)

        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "store", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        fmt.Fprint(w, string(j))
                        return</span>
                }
        }

        <span class="cov0" title="0">if !opts.UsePluginApi </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] plugin api is disable from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "plugin api is disable", logrus.Fields{"method": "plugin", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "plugin api is disable")
                j, _ := json.Marshal(msg)
                fmt.Fprint(w, string(j))
                return</span>
        }

        <span class="cov0" title="0">params := make(map[string]string)
        query := r.URL.Query()
        for _, s := range []string{"command", "cmd"} </span><span class="cov0" title="0">{
                param := query[s]
                if len(param) &gt; 0 </span><span class="cov0" title="0">{
                        params[s] = param[0]
                }</span> else<span class="cov0" title="0"> {
                        params[s] = ""
                }</span>
        }

        <span class="cov0" title="0">hasQuery := false
        if params["command"] != "" || params["cmd"] != "" </span><span class="cov0" title="0">{
                hasQuery = true
        }</span>

        // for GET url-param
        <span class="cov0" title="0">msg := NewPluginMessage(params["command"], params["cmd"])

        // for POST form-data
        if !hasQuery </span><span class="cov0" title="0">{
                r.ParseForm()
                if len(r.Form) &gt; 0 </span><span class="cov0" title="0">{
                        if data, ok := r.Form["json"]; ok </span><span class="cov0" title="0">{
                                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                        json.Unmarshal([]byte(data[0]), msg)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if msg.Command() != "" </span><span class="cov0" title="0">{
                p, err := LoadPlugin()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] plugin can't loaded from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "plugin can't loaded", logrus.Fields{"method": "plugin", "command": msg.Command(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">res := NewResultMessage("fail", "plugin can't loaded")
                        j, _ := json.Marshal(res)
                        fmt.Fprint(w, string(j))</span>
                }

                <span class="cov0" title="0">if proc, ok := p.Plugins[msg.Command()]; ok </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Plugin] call plugin \"%s\" from %s\n", msg.Command(), r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(INFO, "call plugin", logrus.Fields{"method": "plugin", "command": msg.Command(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">ret := ExecPlugin(proc.Proc, proc.Args)
                        fmt.Fprint(w, ret)</span>
                } else<span class="cov0" title="0"> {
                        log.Printf("&gt; [Warning] plugin command not found from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "plugin command not found", logrus.Fields{"method": "plugin", "command": msg.Command(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">res := NewResultMessage("fail", "plugin command not found")
                        j, _ := json.Marshal(res)
                        fmt.Fprint(w, string(j))</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("&gt; [Warning] plugin command is empty from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "plugin command is empty", logrus.Fields{"method": "plugin", "command": msg.Command(), "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">res := NewResultMessage("fail", "plugin command is empty")
                j, _ := json.Marshal(res)
                fmt.Fprint(w, string(j))</span>
        }
}

func AllowCORS(w http.ResponseWriter) <span class="cov8" title="1">{
        w.Header().Set("Access-Control-Allow-Headers", "*")
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "path/filepath"
        "time"

        rotatelogs "github.com/lestrrat-go/file-rotatelogs"
        "github.com/sirupsen/logrus"
)

const (
        INFO = iota + 1
        WARN
)

type Logger struct {
        lgrs *logrus.Logger
}

func NewLogger(logDir string, logFile string) *Logger <span class="cov0" title="0">{
        logPath := filepath.Join(logDir, logFile)
        rotatelog, err := rotatelogs.New(
                logPath+".%Y%m%d",
                rotatelogs.WithLinkName(logPath),
                rotatelogs.WithRotationTime(time.Hour*24),
                rotatelogs.WithMaxAge(time.Hour*24*365*10),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">lg := &amp;Logger{lgrs: logrus.New()}
        lg.lgrs.Formatter = &amp;logrus.JSONFormatter{}
        lg.lgrs.Level = logrus.InfoLevel
        lg.lgrs.Out = rotatelog

        return lg</span>
}

func (*Logger) Log(lv int, msg string, fld logrus.Fields) <span class="cov0" title="0">{
        switch lv </span>{
        case INFO:<span class="cov0" title="0">
                logger.lgrs.WithFields(fld).Info(msg)</span>
        case WARN:<span class="cov0" title="0">
                logger.lgrs.WithFields(fld).Warn(msg)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "strings"
        "sync"
        "syscall"
        "time"

        flags "github.com/jessevdk/go-flags"
        "github.com/sharkattack51/golem"
        "github.com/sirupsen/logrus"
        "github.com/syndtr/goleveldb/leveldb"
)

const (
        VERSION         = "1.3.4"
        LOG_FILE        = "postman.log"
        DB_FILE         = "postman.db"
        SERVE_FILES_DIR = "serve_files"
        PLUGIN_DIR      = "plugin"
        PLUGIN_JSON     = "plugin.json"
        TARGET_PAAS     = false

        ENV_SECRET = "SECRET"
        ENV_PORT   = "PORT"
        ENV_CHLIST = "CHLIST"
        ENV_IPLIST = "IPLIST"
)

type Options struct {
        Port         string `short:"p" long:"port" default:"8800" description:"listen port number"`
        LogDir       string `short:"l" long:"log" description:"output log location"`
        Channels     string `short:"c" long:"chlist" description:"safelist for channels"`
        IpAddresses  string `short:"i" long:"iplist" description:"connectable ip_address list"`
        UseStoreApi  bool   `short:"k" long:"store" description:"enable key-value store api"`
        UseFileApi   bool   `short:"f" long:"file" description:"enable file server api"`
        UsePluginApi bool   `short:"u" long:"plugin" description:"enable plugin api"`
        SecureMode   bool   `short:"s" long:"secure" description:"secure mode"`
        GenToken     bool   `short:"g" long:"generate" description:"genarate token from environment variable [SECRET]"`
}

var (
        srv      *http.Server
        host     string
        roomMg   *golem.RoomManager
        conns    sync.Map // map[string]*golem.Connection
        cliInfos sync.Map // map[string]string
        safeList []string
        ipList   []string
        logger   *Logger
        kvsDB    *leveldb.DB
        opts     Options
        secret   string
)

//
// Main
//

func main() <span class="cov0" title="0">{
        // graceful shutdown for windows
        if !TARGET_PAAS &amp;&amp; runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                RegisterOSHandler(GracefulShutdown)
        }</span>

        // option flags
        <span class="cov0" title="0">_, err := flags.Parse(&amp;opts)
        if err != nil </span><span class="cov0" title="0">{ // [help] also passes
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">Prepare()
        PrintInfo()
        StartServer()

        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM, os.Interrupt)
        defer signal.Stop(sigCh)
        &lt;-sigCh // blocking

        // graceful shutdown
        GracefulShutdown()</span>
}

func Prepare() <span class="cov8" title="1">{
        host = GetHostIP()
        roomMg = golem.NewRoomManager()
        conns = sync.Map{}    // make(map[string]*golem.Connection)
        cliInfos = sync.Map{} // make(map[string]string)

        // for PaaS build
        if TARGET_PAAS </span><span class="cov0" title="0">{
                opts.Port = os.Getenv(ENV_PORT)
                opts.Channels = os.Getenv(ENV_CHLIST)
                opts.IpAddresses = os.Getenv(ENV_IPLIST)
                opts.UseStoreApi = false
                opts.UseFileApi = false
                opts.UsePluginApi = false
        }</span>

        // don't start multiple instance
        <span class="cov8" title="1">l, err := net.Listen("tcp", ":"+opts.Port)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("&gt; [Warning] don't start multiple instance")
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">l.Close()

        // generate token mode
        secret = os.Getenv(ENV_SECRET)
        if opts.GenToken </span><span class="cov0" title="0">{
                if secret == "" </span><span class="cov0" title="0">{
                        log.Fatalln(errors.New("environment variable [" + ENV_SECRET + "] is empty"))
                }</span>

                <span class="cov0" title="0">token, err := GenerateToken(secret, host)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>
                <span class="cov0" title="0">fmt.Println("genarated token: " + token)
                os.Exit(0)</span>
        }

        // safelist for subscribe channnels
        <span class="cov8" title="1">chSplits := strings.Split(opts.Channels, ",")
        for _, ch := range chSplits </span><span class="cov8" title="1">{
                if ch != "" </span><span class="cov0" title="0">{
                        safeList = append(safeList, ch)
                }</span>
        }

        // iplist for secure connection
        <span class="cov8" title="1">ipSplits := strings.Split(opts.IpAddresses, ",")
        for _, ip := range ipSplits </span><span class="cov8" title="1">{
                if ip != "" &amp;&amp; ValidIP4(ip) </span><span class="cov0" title="0">{
                        ipList = append(ipList, ip)
                }</span>
        }

        <span class="cov8" title="1">if !TARGET_PAAS </span><span class="cov8" title="1">{
                // log
                if opts.LogDir != "" </span><span class="cov0" title="0">{
                        logger = NewLogger(opts.LogDir, LOG_FILE)
                }</span>

                <span class="cov8" title="1">var err error

                // store db
                if opts.UseStoreApi </span><span class="cov0" title="0">{
                        kvsDB, err = leveldb.OpenFile(DB_FILE, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("&gt; [Warning] could not open \"%s\": %s\n", DB_FILE, err)

                                // remove .db directory
                                err = os.RemoveAll(DB_FILE)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("&gt; [Warning] could not remove \"%s\": %s\n", DB_FILE, err)
                                }</span> else<span class="cov0" title="0"> {
                                        // one more try
                                        kvsDB, err = leveldb.OpenFile(DB_FILE, nil)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Printf("&gt; [Warning] could not open \"%s\": %s\n", DB_FILE, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Printf("&gt; [Warning] recreated \"%s\"\n", DB_FILE)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">defer kvsDB.Close()</span>
                }

                // file api document root
                <span class="cov8" title="1">if opts.UseFileApi </span><span class="cov0" title="0">{
                        if !IsExist(SERVE_FILES_DIR) </span><span class="cov0" title="0">{
                                err = os.Mkdir(SERVE_FILES_DIR, 0777)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("&gt; [Warning] could not create \"%s\" directory\n", SERVE_FILES_DIR)
                                }</span>
                        }
                }
        }
}

func PrintInfo() <span class="cov0" title="0">{
        fmt.Println("===================================================")
        fmt.Printf("[[ Postman v%s ]]\n", VERSION)
        fmt.Println(SecureSprintf(fmt.Sprintf("websocket server start... ws://%s:%s/postman", host, opts.Port)+"%s", "?tkn=TOKEN"))
        fmt.Println("")
        fmt.Println("=== Websocket API ===")
        fmt.Println("[Ping]")
        fmt.Println("&lt;- \"ping {}\"")
        fmt.Println("[Status]")
        fmt.Println("&lt;- \"status {}\"")
        fmt.Println("[Subscribe]")
        fmt.Println("&lt;- \"subscribe {\"ch\":\"CHANNEL\",[\"ci\":\"CLIENT_INFO\"]}\"")
        fmt.Println("[Unsubscribe]")
        fmt.Println("&lt;- \"unsubscribe {\"ch\":\"CHANNEL\"}\"")
        fmt.Println("[Publish]")
        fmt.Println("&lt;- \"publish {\"ch\":\"CHANNEL\",\"msg\":\"MESSAGE\",[\"tag\":\"TAG\",\"ext\":\"OTHER\"]}\"")
        fmt.Println("")
        fmt.Println("=== Http API ===")
        fmt.Printf("http://%s:%s/postman\n", host, opts.Port)
        fmt.Println("[Status]")
        fmt.Println(SecureSprintf("(GET) /status%s", "?tkn=TOKEN"))
        fmt.Println(SecureSprintf("(GET) /status_pp%s", "?tkn=TOKEN"))
        fmt.Println("[Publish]")
        fmt.Println(SecureSprintf("(GET) /publish?ch=CHANNEL&amp;msg=MESSAGE[&amp;tag=TAG&amp;ext=OTHER&amp;ci=CLIENT_INFO]%s", "&amp;tkn=TOKEN"))
        fmt.Println(SecureSprintf("(POST) /publish &lt;- json={\"ch\":\"CHANNEL\",\"msg\":\"MESSAGE\",[\"tag\":\"TAG\",\"ext\":\"OTHER\",\"ci\":\"CLIENT_INFO\"]%s}", ",\"tkn\":\"TOKEN\""))
        if opts.UseStoreApi &amp;&amp; kvsDB != nil </span><span class="cov0" title="0">{
                fmt.Println("[Store]")
                fmt.Println(SecureSprintf("(GET) /store?cmd=(GET|SET|HAS|DEL)&amp;key=KEY[&amp;val=VALUE]%s", "&amp;tkn=TOKEN"))
                fmt.Println(SecureSprintf("(POST) /store &lt;- json={\"cmd\":\"(GET|SET|HAS|DEL)\",\"key\":\"KEY\",[\"val\":\"VALUE\"]%s}", ",\"tkn\":\"TOKEN\""))
        }</span>
        <span class="cov0" title="0">if opts.UseFileApi </span><span class="cov0" title="0">{
                fmt.Println("[File]")
                fmt.Println(SecureSprintf("(GET) /file/FILE_NAME%s", "?tkn=TOKEN"))
                fmt.Println(SecureSprintf("(POST) /file &lt;- file=FILE_BINARY %s", "json={\"tkn\":\"TOKEN\"}"))
        }</span>
        <span class="cov0" title="0">if opts.UsePluginApi </span><span class="cov0" title="0">{
                fmt.Println("[Plugin]")
                fmt.Println(SecureSprintf("(GET) /plugin?cmd=COMMAND%s", "&amp;tkn=TOKEN"))
                fmt.Println(SecureSprintf("(POST) /plugin &lt;- json={\"cmd\":COMMAND%s}", ",\"tkn\":\"TOKEN\""))
        }</span>
        <span class="cov0" title="0">fmt.Println("===================================================")
        fmt.Println("")</span>
}

func StartServer() <span class="cov0" title="0">{
        srv = &amp;http.Server{Addr: ":" + opts.Port}

        // websocket routing
        http.HandleFunc("/postman", CreateRouter().Handler())

        // http routing
        http.HandleFunc("/postman/publish", PublishHandler)
        http.HandleFunc("/postman/status", StatusHandler)
        http.HandleFunc("/postman/status_pp", StatusPpHandler)
        http.HandleFunc("/postman/store", StoreHandler)
        http.HandleFunc("/postman/file/", FileHandler)
        http.HandleFunc("/postman/plugin", PluginHandler)

        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>
        }()

        <span class="cov0" title="0">if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "postman start", logrus.Fields{"host": host, "port": opts.Port})
        }</span>
}

func GracefulShutdown() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
}

func SecureSprintf(s string, ss string) string <span class="cov0" title="0">{
        if opts.SecureMode </span><span class="cov0" title="0">{
                return fmt.Sprintf(s, ss)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf(s, "")
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"

        "github.com/sharkattack51/golem"
)

//
// Secure
//

type SecureMessage struct {
        RawToken string `json:"token"`
        RawTkn   string `json:"tkn"`
}

func (m *SecureMessage) Token() string <span class="cov0" title="0">{
        if m.RawToken != "" </span><span class="cov0" title="0">{
                return m.RawToken
        }</span> else<span class="cov0" title="0"> {
                return m.RawTkn
        }</span>
}

func NewSecureMessage(token string, tkn string) *SecureMessage <span class="cov0" title="0">{
        msg := &amp;SecureMessage{
                RawToken: token,
                RawTkn:   tkn,
        }
        return msg
}</span>

//
// Subscribe
//

type SubscribeMessage struct {
        RawChannel    string `json:"channel"`
        RawCh         string `json:"ch"`
        RawClientInfo string `json:"client_info"`
        RawCi         string `json:"ci"`
}

func (m *SubscribeMessage) Channel() string <span class="cov8" title="1">{
        if m.RawChannel != "" </span><span class="cov0" title="0">{
                return m.RawChannel
        }</span> else<span class="cov8" title="1"> {
                return m.RawCh
        }</span>
}

func (m *SubscribeMessage) Info() string <span class="cov8" title="1">{
        if m.RawClientInfo != "" </span><span class="cov0" title="0">{
                return m.RawClientInfo
        }</span> else<span class="cov8" title="1"> {
                return m.RawCi
        }</span>
}

//
// Publish
//

type PublishMessage struct {
        RawChannel    string `json:"channel"`
        RawCh         string `json:"ch"`
        RawMessage    string `json:"message"`
        RawMsg        string `json:"msg"`
        RawTag        string `json:"tag"`
        RawExtention  string `json:"extention"`
        RawExt        string `json:"ext"`
        RawClientInfo string `json:"client_info"`
        RawCi         string `json:"ci"`
}

func (m *PublishMessage) Channel() string <span class="cov8" title="1">{
        if m.RawChannel != "" </span><span class="cov0" title="0">{
                return m.RawChannel
        }</span> else<span class="cov8" title="1"> {
                return m.RawCh
        }</span>
}

func (m *PublishMessage) Message() string <span class="cov8" title="1">{
        if m.RawMessage != "" </span><span class="cov8" title="1">{
                return m.RawMessage
        }</span> else<span class="cov8" title="1"> {
                return m.RawMsg
        }</span>
}

func (m *PublishMessage) Tag() string <span class="cov8" title="1">{
        return m.RawTag
}</span>

func (m *PublishMessage) Extention() string <span class="cov8" title="1">{
        if m.RawExtention != "" </span><span class="cov0" title="0">{
                return m.RawExtention
        }</span> else<span class="cov8" title="1"> {
                return m.RawExt
        }</span>
}

func (m *PublishMessage) Info() string <span class="cov8" title="1">{
        if m.RawClientInfo != "" </span><span class="cov0" title="0">{
                return m.RawClientInfo
        }</span> else<span class="cov8" title="1"> {
                return m.RawCi
        }</span>
}

func NewPublishMessage(channel string, ch string, message string, msg string, tag string, extention string, ext string, client_info string, ci string) *PublishMessage <span class="cov8" title="1">{
        pmsg := &amp;PublishMessage{
                RawChannel:    channel,
                RawCh:         ch,
                RawMessage:    message,
                RawMsg:        msg,
                RawTag:        tag,
                RawExtention:  extention,
                RawExt:        ext,
                RawClientInfo: client_info,
                RawCi:         ci,
        }
        return pmsg
}</span>

type PublishSendMessage struct {
        Channel   string `json:"channel"`
        Message   string `json:"message"`
        Tag       string `json:"tag"`
        Extention string `json:"extention"`
}

func NewPublishSendMessage(channel string, message string, tag string, extention string) *PublishSendMessage <span class="cov8" title="1">{
        msg := &amp;PublishSendMessage{
                Channel:   channel,
                Message:   message,
                Tag:       tag,
                Extention: extention,
        }
        return msg
}</span>

func (msg *PublishMessage) BuildLogString() string <span class="cov8" title="1">{
        msgStr := ""
        if msg.Tag() != "" </span><span class="cov0" title="0">{
                if msg.Extention() != "" </span><span class="cov0" title="0">{
                        msgStr = fmt.Sprintf("%s/%s/%s", msg.Message(), msg.Tag(), msg.Extention())
                }</span> else<span class="cov0" title="0"> {
                        msgStr = fmt.Sprintf("%s/%s", msg.Message(), msg.Tag())
                }</span>
        } else<span class="cov8" title="1"> {
                if msg.Extention() != "" </span><span class="cov0" title="0">{
                        msgStr = fmt.Sprintf("%s/%s", msg.Message(), msg.Extention())
                }</span> else<span class="cov8" title="1"> {
                        msgStr = msg.Message()
                }</span>
        }

        <span class="cov8" title="1">return msgStr</span>
}

//
// Status
//

type StatusMessage struct {
        Version  string              `json:"version"`
        Channels map[string][]string `json:"channels"`
}

func NewStatusMessage(rm *golem.RoomManager) *StatusMessage <span class="cov8" title="1">{
        channels := make(map[string][]string)

        if rm != nil </span><span class="cov8" title="1">{
                for i, ri := range rm.GetRoomInfos() </span><span class="cov8" title="1">{
                        remoteAddrs := []string{}
                        for _, c := range ri.Room.GetMembers() </span><span class="cov8" title="1">{
                                remoteAddr := c.GetSocket().RemoteAddr().String()
                                infoAtRemote := remoteAddr
                                if info, exist := cliInfos.Load(remoteAddr); exist </span><span class="cov0" title="0">{
                                        infoAtRemote = info.(string) + "@" + remoteAddr
                                }</span>

                                <span class="cov8" title="1">if TARGET_PAAS </span><span class="cov0" title="0">{
                                        // mask ip address
                                        infoAtRemote = fmt.Sprintf("conn_%d", i)
                                }</span>

                                <span class="cov8" title="1">remoteAddrs = append(remoteAddrs, infoAtRemote)</span>
                        }
                        <span class="cov8" title="1">channels[ri.Topic] = remoteAddrs</span>
                }
        }

        <span class="cov8" title="1">msg := &amp;StatusMessage{
                Version:  VERSION,
                Channels: channels,
        }
        return msg</span>
}

//
// Store
//

type StoreMessage struct {
        RawCommand string `json:"command"`
        RawCmd     string `json:"cmd"`
        RawKey     string `json:"key"`
        RawValue   string `json:"value"`
        RawVal     string `json:"val"`
}

func (m *StoreMessage) Command() string <span class="cov0" title="0">{
        if m.RawCommand != "" </span><span class="cov0" title="0">{
                return m.RawCommand
        }</span> else<span class="cov0" title="0"> {
                return m.RawCmd
        }</span>
}

func (m *StoreMessage) Key() string <span class="cov0" title="0">{
        return m.RawKey
}</span>

func (m *StoreMessage) Value() string <span class="cov0" title="0">{
        if m.RawValue != "" </span><span class="cov0" title="0">{
                return m.RawValue
        }</span> else<span class="cov0" title="0"> {
                return m.RawVal
        }</span>
}

func NewStoreMessage(command string, cmd string, key string, value string, val string) *StoreMessage <span class="cov0" title="0">{
        msg := &amp;StoreMessage{
                RawCommand: command,
                RawCmd:     cmd,
                RawKey:     key,
                RawValue:   value,
                RawVal:     val,
        }
        return msg
}</span>

//
// Result
//

type ResultMessage struct {
        Result string `json:"result"`
        Error  string `json:"error"`
}

func NewResultMessage(result string, err string) *ResultMessage <span class="cov8" title="1">{
        msg := &amp;ResultMessage{
                Result: result,
                Error:  err,
        }
        return msg
}</span>

//
// Plugin
//

type PluginMessage struct {
        RawCommand string `json:"command"`
        RawCmd     string `json:"cmd"`
}

func (m *PluginMessage) Command() string <span class="cov0" title="0">{
        if m.RawCommand != "" </span><span class="cov0" title="0">{
                return m.RawCommand
        }</span> else<span class="cov0" title="0"> {
                return m.RawCmd
        }</span>
}

func NewPluginMessage(command string, cmd string) *PluginMessage <span class="cov0" title="0">{
        msg := &amp;PluginMessage{
                RawCommand: command,
                RawCmd:     cmd,
        }
        return msg
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// +build !windows

package main

func RegisterOSHandler(callback func()) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "encoding/json"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
)

type PluginsData struct {
        Plugins map[string]*ProcData `json:"plugins"`
}

func NewEmptyPluginsData() *PluginsData <span class="cov0" title="0">{
        plugins := make(map[string]*ProcData)
        plugins["example"] = NewEmptyProcData()
        data := &amp;PluginsData{
                Plugins: plugins,
        }
        return data
}</span>

type ProcData struct {
        Proc string   `json:"proc"`
        Args []string `json:"args"`
}

func NewEmptyProcData() *ProcData <span class="cov0" title="0">{
        proc := &amp;ProcData{
                Proc: "",
                Args: []string{},
        }
        return proc
}</span>

func LoadPlugin() (*PluginsData, error) <span class="cov0" title="0">{
        if !IsExist(PLUGIN_DIR) </span><span class="cov0" title="0">{
                os.Mkdir(PLUGIN_DIR, 0777)
        }</span>

        <span class="cov0" title="0">path := filepath.Join(PLUGIN_DIR, PLUGIN_JSON)
        if !IsExist(path) </span><span class="cov0" title="0">{
                j, _ := json.MarshalIndent(NewEmptyPluginsData(), "", "    ")
                ioutil.WriteFile(path, []byte(j), 0644)
        }</span>

        <span class="cov0" title="0">f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        b, err := ioutil.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var p PluginsData
        err = json.Unmarshal(b, &amp;p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;p, nil</span>
}

func ExecPlugin(proc string, args []string) string <span class="cov0" title="0">{
        c := make(chan string)
        go func() </span><span class="cov0" title="0">{
                out, err := exec.Command(proc, args...).Output()
                if err != nil </span><span class="cov0" title="0">{
                        c &lt;- err.Error()
                }</span> else<span class="cov0" title="0"> {
                        c &lt;- string(out)
                }</span>
        }()
        <span class="cov0" title="0">return &lt;-c</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "errors"

        "github.com/syndtr/goleveldb/leveldb"
)

func StoreGet(db *leveldb.DB, msg *StoreMessage) (string, error) <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                data, err := db.Get([]byte(msg.Key()), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return string(data), nil</span>
        } else<span class="cov0" title="0"> {
                return "", errors.New("db is nil")
        }</span>
}

func StoreSet(db *leveldb.DB, msg *StoreMessage) error <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                err := db.Put([]byte(msg.Key()), []byte(msg.Value()), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                return errors.New("db is nil")
        }</span>
}

func StoreHas(db *leveldb.DB, msg *StoreMessage) (bool, error) <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                ret, err := db.Has([]byte(msg.Key()), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return ret, nil</span>
        } else<span class="cov0" title="0"> {
                return false, errors.New("db is nil")
        }</span>
}

func StoreDelete(db *leveldb.DB, msg *StoreMessage) error <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                err := db.Delete([]byte(msg.Key()), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                return errors.New("db is nil")
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "net"
        "os"
        "regexp"
        "runtime"
        "strings"

        "github.com/sharkattack51/golem"
)

//
// Util Functions
//

func GetHostIP() string <span class="cov8" title="1">{
        ip := "127.0.0.1"
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                host, _ := os.Hostname()
                addrs, _ := net.LookupIP(host)
                for _, a := range addrs </span><span class="cov0" title="0">{
                        if ipv4 := a.To4(); ipv4 != nil </span><span class="cov0" title="0">{
                                ip = ipv4.String()
                                break</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                addrs, _ := net.InterfaceAddrs()
                for _, a := range addrs </span><span class="cov8" title="1">{
                        if ipnet, ok := a.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov8" title="1">{
                                if ipnet.IP.To4() != nil </span><span class="cov8" title="1">{
                                        ip = ipnet.IP.String()
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return ip</span>
}

func GetRemoteIPfromConn(conn *golem.Connection) string <span class="cov0" title="0">{
        ip := ""
        conns.Range(func(a interface{}, c interface{}) bool </span><span class="cov0" title="0">{
                if c.(*golem.Connection) == conn </span><span class="cov0" title="0">{
                        ip = a.(string)
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">return SplitAddr(ip)</span>
}

func SplitAddr(ip string) string <span class="cov0" title="0">{
        if strings.Contains(ip, ":") </span><span class="cov0" title="0">{
                ip = strings.Split(ip, ":")[0]
        }</span>

        <span class="cov0" title="0">return ip</span>
}

func ValidIP4(ip string) bool <span class="cov0" title="0">{
        ip = strings.Trim(ip, " ")

        re, _ := regexp.Compile(`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`)
        return re.MatchString(ip)
}</span>

func IpValidation(addr string) bool <span class="cov8" title="1">{
        valid := true
        for _, ip := range ipList </span><span class="cov0" title="0">{
                if !strings.Contains(addr, ip) </span><span class="cov0" title="0">{
                        valid = false
                        break</span>
                }
        }
        <span class="cov8" title="1">return valid</span>
}

func IsExist(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return !os.IsNotExist(err)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "encoding/json"
        "log"
        "net/http"
        "strings"
        "time"

        "github.com/sharkattack51/golem"
        "github.com/sirupsen/logrus"
)

//
// Websocket Handlers
//

func CreateRouter() *golem.Router <span class="cov8" title="1">{
        router := golem.NewRouter()
        router.OnConnect(Connected)
        router.On("ping", Ping)
        router.On("subscribe", Subscribe)
        router.On("unsubscribe", Unsubscribe)
        router.On("publish", Publish)
        router.On("status", Status)
        router.OnClose(Closed)

        return router
}</span>

func Connected(conn *golem.Connection, r *http.Request) <span class="cov8" title="1">{
        if !IpValidation(r.RemoteAddr) </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] remote ip blocked from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "remote ip blocked", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">msg := NewResultMessage("fail", "remote ip blocked")
                j, _ := json.Marshal(msg)
                conn.Emit("message", string(j))

                go func(c *golem.Connection) </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * 1)
                        c.Close()
                }</span>(conn)

                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if opts.SecureMode </span><span class="cov0" title="0">{
                smsg := SecureHandler(r)
                res, err := Authenticate(secret, smsg.Token(), host)
                if !res || err != nil </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] authentication failed from %s\n", r.RemoteAddr)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "authentication failed", logrus.Fields{"method": "connect", "token": smsg.Token(), "from": r.RemoteAddr})
                        }</span>

                        <span class="cov0" title="0">msg := NewResultMessage("fail", "security error")
                        j, _ := json.Marshal(msg)
                        conn.Emit("message", string(j))

                        go func(c *golem.Connection) </span><span class="cov0" title="0">{
                                time.Sleep(time.Millisecond * 1)
                                c.Close()
                        }</span>(conn)

                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov8" title="1">if hasconn, exist := conns.Load(r.RemoteAddr); exist </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] %s is already connecting\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "already connecting", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>

                <span class="cov0" title="0">hasconn.(*golem.Connection).Close()

                go func(c *golem.Connection) </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * 1)
                        c.Close()
                }</span>(conn)
        } else<span class="cov8" title="1"> {
                conns.Store(r.RemoteAddr, conn)

                log.Printf("&gt; [Connected] from %s\n", r.RemoteAddr)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(INFO, "new connection", logrus.Fields{"method": "connect", "from": r.RemoteAddr})
                }</span>
        }
}

func Ping(conn *golem.Connection) <span class="cov0" title="0">{
        conn.Emit("message", "pong")
}</span>

func Subscribe(conn *golem.Connection, msg *SubscribeMessage) <span class="cov8" title="1">{
        remoteAddr := conn.GetSocket().RemoteAddr().String()
        infoAtRemote := remoteAddr
        if msg.Info() != "" </span><span class="cov0" title="0">{
                infoAtRemote = msg.Info() + "@" + remoteAddr
        }</span>

        <span class="cov8" title="1">if msg.Channel() == "" </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] subscribe channel is empty from %s\n", infoAtRemote)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "subscribe channel is empty", logrus.Fields{"method": "subscribe", "channel": msg.Channel(), "from": infoAtRemote})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">if len(safeList) &gt; 0 </span><span class="cov0" title="0">{
                contain := false
                for _, ch := range safeList </span><span class="cov0" title="0">{
                        if msg.Channel() == ch </span><span class="cov0" title="0">{
                                contain = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !contain </span><span class="cov0" title="0">{
                        log.Printf("&gt; [Warning] whitelist does not contain subscribe channel from %s\n", infoAtRemote)
                        if logger != nil </span><span class="cov0" title="0">{
                                logger.Log(WARN, "whitelist does not contain subscribe channel", logrus.Fields{"method": "subscribe", "channel": msg.Channel(), "from": infoAtRemote})
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov8" title="1">log.Printf("&gt; [Subscribe] ch:%s from %s\n", msg.Channel(), infoAtRemote)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "new subscribe", logrus.Fields{"method": "subscribe", "channel": msg.Channel(), "from": infoAtRemote})
        }</span>

        <span class="cov8" title="1">if msg.Info() != "" </span><span class="cov0" title="0">{
                cliInfos.Store(remoteAddr, msg.Info())
        }</span>

        <span class="cov8" title="1">roomMg.Join(msg.Channel(), conn)</span>
}

func Unsubscribe(conn *golem.Connection, msg *SubscribeMessage) <span class="cov0" title="0">{
        remoteAddr := conn.GetSocket().RemoteAddr().String()
        infoAtRemote := remoteAddr
        if msg.Info() != "" </span><span class="cov0" title="0">{
                infoAtRemote = msg.Info() + "@" + remoteAddr
        }</span>

        <span class="cov0" title="0">if msg.Channel() == "" </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] unsubscribe channel is empty from %s\n", infoAtRemote)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "unsubscribe channel is empty", logrus.Fields{"method": "unsubscribe", "channel": msg.Channel(), "from": infoAtRemote})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">log.Printf("&gt; [Unsubscribe] ch:%s from %s\n", msg.Channel(), infoAtRemote)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "unsubscribe", logrus.Fields{"method": "unsubscribe", "channel": msg.Channel(), "from": infoAtRemote})
        }</span>

        <span class="cov0" title="0">cliInfos.Delete(remoteAddr)
        roomMg.Leave(msg.Channel(), conn)</span>
}

func Publish(conn *golem.Connection, msg *PublishMessage) <span class="cov8" title="1">{
        remoteAddr := conn.GetSocket().RemoteAddr().String()
        infoAtRemote := remoteAddr
        if info, exist := cliInfos.Load(remoteAddr); exist </span><span class="cov0" title="0">{
                infoAtRemote = info.(string) + "@" + remoteAddr
        }</span> else<span class="cov8" title="1"> if msg.Info() != "" </span><span class="cov0" title="0">{
                infoAtRemote = msg.Info() + "@" + remoteAddr
        }</span>

        <span class="cov8" title="1">if msg.Channel() == "" </span><span class="cov0" title="0">{
                log.Printf("&gt; [Warning] publish channel is empty from %s\n", infoAtRemote)
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Log(WARN, "publish channel is empty", logrus.Fields{"method": "publish", "channel": msg.Channel(), "message": msg.Message(), "tag": msg.Tag(), "extention": msg.Extention(), "from": infoAtRemote})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">log.Printf("&gt; [Publish] ch:%s msg:%s from %s\n", msg.Channel(), msg.BuildLogString(), infoAtRemote)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "new publish", logrus.Fields{"method": "publish", "channel": msg.Channel(), "message": msg.Message(), "tag": msg.Tag(), "extention": msg.Extention(), "from": infoAtRemote})
        }</span>

        <span class="cov8" title="1">pmsg := NewPublishSendMessage(msg.Channel(), msg.Message(), msg.Tag(), msg.Extention())
        if strings.HasSuffix(msg.Channel(), "/*") </span><span class="cov0" title="0">{
                groupCh := strings.TrimSuffix(msg.Channel(), "/*")
                for _, ri := range roomMg.GetRoomInfos() </span><span class="cov0" title="0">{
                        if strings.HasPrefix(ri.Topic, groupCh) </span><span class="cov0" title="0">{
                                ck := strings.TrimPrefix(ri.Topic, groupCh)
                                if len(ck) &gt; 0 &amp;&amp; strings.HasPrefix(ck, "/") </span><span class="cov0" title="0">{
                                        roomMg.Emit(ri.Topic, "message", &amp;pmsg)
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                roomMg.Emit(msg.Channel(), "message", &amp;pmsg)
        }</span>
}

func Status(conn *golem.Connection) <span class="cov0" title="0">{
        msg := NewStatusMessage(roomMg)

        conn.Emit("message", &amp;msg)
}</span>

func Closed(conn *golem.Connection) <span class="cov8" title="1">{
        remoteAddr := conn.GetSocket().RemoteAddr().String()

        conns.Delete(remoteAddr)

        infoAtRemote := remoteAddr
        if info, exist := cliInfos.Load(remoteAddr); exist </span><span class="cov0" title="0">{
                cliInfos.Delete(remoteAddr)

                infoAtRemote = info.(string) + "@" + remoteAddr
        }</span>

        <span class="cov8" title="1">log.Printf("&gt; [Closed] from %s\n", infoAtRemote)
        if logger != nil </span><span class="cov0" title="0">{
                logger.Log(INFO, "connection close", logrus.Fields{"method": "close", "from": infoAtRemote})
        }</span>

        <span class="cov8" title="1">roomMg.LeaveAll(conn)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
